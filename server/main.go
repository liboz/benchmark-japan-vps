package main

import (
	"context"
	"encoding/csv"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/exec"
	"strconv"
	"sync"
	"time"

	"github.com/bufbuild/connect-go"
	"github.com/docker/go-units"

	benchmarkv1 "liboz/benchmark-japan-vps/gen/service/v1"        // generated by protoc-gen-go
	"liboz/benchmark-japan-vps/gen/service/v1/benchmarkv1connect" // generated by protoc-gen-connect-go
)

var PORT = 8000
var RESULTS = []*benchmarkv1.BenchmarkResult{}
var SCRIPT = "./run_and_parse_bench.sh"
var DEBUG = false

func csvToResult(csvData [][]string) *benchmarkv1.BenchmarkResult {
	if DEBUG {
		fmt.Println(csvData)
	}
	result := &benchmarkv1.BenchmarkResult{}
	index := 0
	ioSpeedData := csvData[index]
	if ioSpeedData[0] == "I/O Speed" {
		sizeInBytes, err := units.FromHumanSize(ioSpeedData[1])
		if err == nil {
			result.IoSpeed = sizeInBytes
		} else {
			log.Printf("Error parsing io speed %s\n", err)
		}
	}

	index = 1
	currRow := csvData[index]
	for len(currRow) == 4 {
		speedTestResult := benchmarkv1.SpeedTestResult{}
		speedTestResult.City = currRow[0]
		speedTestResult.Country = currRow[1]
		sizeInBytes, err := units.FromHumanSize(currRow[2])
		if err == nil {
			speedTestResult.UploadSpeed = sizeInBytes
		} else {
			log.Printf("Error parsing upload speed %s\n", err)
		}

		sizeInBytes, err = units.FromHumanSize(currRow[3])
		if err == nil {
			speedTestResult.DownloadSpeed = sizeInBytes
		} else {
			log.Printf("Error parsing download speed %s\n", err)
		}
		result.SpeedTestResults = append(result.SpeedTestResults, &speedTestResult)
		index += 1
		currRow = csvData[index]
	}

	geekbench_single := csvData[index]
	if geekbench_single[0] == "Single Core" {
		parsed, err := units.FromHumanSize(geekbench_single[1])
		if err == nil {
			result.SingleCoreGeekbench = parsed
		} else {
			log.Printf("Error parsing geekbench single %s\n", err)
		}
	}

	index += 1
	geekbench_multi := csvData[index]
	if geekbench_multi[0] == "Multi Core" {
		parsed, err := units.FromHumanSize(geekbench_multi[1])
		if err == nil {
			result.MultiCoreGeekbench = parsed
		} else {
			log.Printf("Error parsing geekbench multi %s\n", err)
		}
	}

	index += 1
	for index < len(csvData) {
		currRow = csvData[index]

		pingTestResult := benchmarkv1.PingTestResult{}
		pingTestResult.Url = currRow[0]
		parsed, err := units.FromHumanSize(currRow[1])
		if err == nil {
			pingTestResult.DroppedPackets = &parsed
		} else {
			log.Printf("Error parsing dropped packets for %s: %s\n", csvData, err)
		}

		bitSize := 64
		parsedDouble, err := strconv.ParseFloat(currRow[2], bitSize)
		if err == nil {
			pingTestResult.MinimumPing = parsedDouble
		} else {
			log.Printf("Error parsing minimum ping for %s: %s\n", csvData, err)
		}

		parsedDouble, err = strconv.ParseFloat(currRow[3], bitSize)
		if err == nil {
			pingTestResult.AveragePing = parsedDouble
		} else {
			log.Printf("Error parsing average ping for %s: %s\n", csvData, err)
		}

		parsedDouble, err = strconv.ParseFloat(currRow[4], bitSize)
		if err == nil {
			pingTestResult.MaximumPing = parsedDouble
		} else {
			log.Printf("Error parsing max ping for %s: %s\n", csvData, err)
		}

		parsedDouble, err = strconv.ParseFloat(currRow[5], bitSize)
		if err == nil {
			pingTestResult.StandardDeviation = parsedDouble
		} else {
			log.Printf("Error parsing ping std deviation for %s: %s\n", csvData, err)
		}

		result.PingTestResults = append(result.PingTestResults, &pingTestResult)
		index += 1
	}
	return result
}

type BenchmarkServer struct {
	mutex sync.Mutex
}

func (s *BenchmarkServer) updateResults(result *benchmarkv1.BenchmarkResult) {
	s.mutex.Lock()
	defer s.mutex.Unlock()
	RESULTS = append(RESULTS, result)
}

func (s *BenchmarkServer) runBenchmark() *benchmarkv1.BenchmarkResult {
	startTime := time.Now().Unix()

	cmd := exec.Command("/bin/bash", SCRIPT)
	output, err := cmd.CombinedOutput()
	if DEBUG {
		log.Println(string(output))
	}
	if err != nil {
		log.Printf("Error running benchmark/parse script %s\n", err)
		return nil
	}

	endTime := time.Now().Unix()
	log.Printf("Benchmark took %ds to run", endTime-startTime)

	f, err := os.Open("parsed_result.csv")
	if err != nil {
		log.Printf("Error opening result csv file %s\n", err)
		return nil
	}
	defer f.Close()

	// read csv values using csv.Reader
	csvReader := csv.NewReader(f)
	csvReader.FieldsPerRecord = -1
	data, err := csvReader.ReadAll()
	if err != nil {
		log.Printf("Error reading result csv file %s\n", err)
		return nil
	}

	// convert records to array of structs
	result := csvToResult(data)
	result.StartTime = startTime
	result.EndTime = endTime
	s.updateResults(result)

	return result
}

func (s *BenchmarkServer) StartBenchmark(
	ctx context.Context,
	req *connect.Request[benchmarkv1.StartBenchmarkRequest],
) (*connect.Response[benchmarkv1.StartBenchmarkResponse], error) {
	log.Printf("%s: Start benchmark run", time.Now())
	result := s.runBenchmark()
	log.Printf("%s: Benchmark run, returning %s", time.Now(), result)
	return connect.NewResponse(&benchmarkv1.StartBenchmarkResponse{Result: result}), nil
}

func (s *BenchmarkServer) GetResults(
	ctx context.Context,
	req *connect.Request[benchmarkv1.GetResultsRequest],
) (*connect.Response[benchmarkv1.GetResultsResponse], error) {
	s.mutex.Lock()
	currentResults := RESULTS
	RESULTS = []*benchmarkv1.BenchmarkResult{}
	s.mutex.Unlock()
	log.Printf("%s: Getting results, returning %s", time.Now(), currentResults)
	return connect.NewResponse(&benchmarkv1.GetResultsResponse{Results: currentResults}), nil
}

func main() {
	argsWithoutProg := os.Args[1:]
	if len(argsWithoutProg) > 0 {
		DEBUG, _ = strconv.ParseBool(argsWithoutProg[0])
	}

	benchmarkServer := &BenchmarkServer{}
	mux := http.NewServeMux()
	path, handler := benchmarkv1connect.NewBenchmarkServiceHandler(benchmarkServer)
	mux.Handle(path, handler)

	log.Printf("Starting server on port %d with DEBUG: [%v]\n", PORT, DEBUG)
	log.Fatal(http.ListenAndServe(":"+fmt.Sprintf("%d", PORT), mux))
}
